<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>ãƒ—ãƒ¬ã‚¤ã‚¢ãƒ©ã‚¦ãƒ³ãƒ‰ v21ï¼ˆé«˜é€Ÿã‚µãƒ ãƒç”Ÿæˆ + ä¸¦åˆ—åˆ¶é™ + ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼åŸå¯¸ï¼‰</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --sidebar-w: 300px; --preview-w: 300px; --header-h: 80px; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans JP", sans-serif; margin:0; background:#eee; overflow:hidden; }
    h1 { background:#444; color:#fff; padding:1em; text-align:center; margin:0; height:var(--header-h); box-sizing:border-box; display:flex; align-items:center; justify-content:center; gap:1rem; position:relative; }
    #session-indicator { position:absolute; right:12px; top:50%; transform:translateY(-50%); color:#ddd; font-size:12px; opacity:.9; }
    #upload-area { padding:16px; text-align:center; background:#fff; cursor:pointer; border-bottom:2px solid #ccc; user-select:none; }
    #file-input { display:none; }
    #sidebar { width:var(--sidebar-w); height:calc(100vh - var(--header-h) - 120px); float:left; background:#fff; border-right:2px solid #aaa; box-shadow:2px 0 5px rgba(0,0,0,.2); padding:10px; box-sizing:border-box; }
    #sidebar h2 { font-size:14px; text-align:center; margin:20px 0 10px; }
    #sidebar button { width:100%; margin-bottom:10px; padding:10px; font-size:14px; cursor:pointer; }
    
    /* è¿½åŠ : ãƒ«ãƒ¼ãƒ çµ‚äº†ãƒœã‚¿ãƒ³ã®ã‚¹ã‚¿ã‚¤ãƒ« */
    #sidebar button.danger { background:#c62828; color:#fff; }
    #sidebar button.danger:disabled { opacity:.6; cursor:not-allowed; }
    
    #field-size-options { display:none; margin-top:5px; text-align:center; }
    #field-size-options button { width:30%; margin:5px 2%; padding:5px; font-size:13px; }
    #container { width:calc(100% - var(--sidebar-w) - var(--preview-w)); height:calc(100vh - var(--header-h) - 120px); overflow:hidden; position:relative; float:left; background:#f7f7f7; }
    #field { position:absolute; transform-origin:0 0; background:none; }
    .player-area { position:absolute; width:50%; height:50%; border:5px dashed #666; box-sizing:border-box; }
    .player-1{ top:0; left:0; } .player-2{ top:0; left:50%; } .player-3{ top:50%; left:0; } .player-4{ top:50%; left:50%; }
    .play-area{ position:relative; left:0; width:100%; height:66.66%; display:flex; flex-direction: row-reverse; z-index:0; }
    .deck-area{ width:33.33%; background:#f90; } .main-play-area{ width:66.66%; background:#2d8; }
    .hand-area{ position:relative; bottom:0; left:0; width:100%; height:33.33%; background:#228be6; z-index:0; }
    .card{ width:120px; height:160px; position:absolute; border:2px solid #333; border-radius:10px; box-shadow:2px 2px 5px rgba(0,0,0,.4); background:#fff; cursor:grab; user-select:none; transition:border .2s; z-index:1; }
    .card[data-owner="other"]{ cursor:not-allowed; opacity:.95; }
    .card{ transform-origin: 50% 50%; }    /* è¿½åŠ : ã‚«ãƒ¼ãƒ‰å›è»¢ã®åŸºæº–ç‚¹ã‚’ä¸­å¤®ã« */
    .card img{ width:100%; height:100%; border-radius:10px; object-fit:cover; pointer-events:none; user-select:none; image-rendering: -webkit-optimize-contrast; }
    .card.selected{ border:3px solid red; }
    #preview{ width:var(--preview-w); height:calc(100vh - var(--header-h) - 120px); float:right; background:#fff; border-left:2px solid #aaa; box-shadow:-2px 0 5px rgba(0,0,0,.2); padding:10px; box-sizing:border-box; }
    #preview h2{ font-size:14px; margin:0 0 10px; text-align:center; } #preview-img{ width:100%; height:auto; border-radius:10px; display:none; }
    
    /* è¿½åŠ : ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’ä¸Š2/3 + ä¸‹1/3(HP) ã«åˆ†å‰² */
    #preview { display:flex; flex-direction:column; }
    #preview-top { flex:2 1 0; overflow:auto; }
    #hp-panel { flex:1 1 0; border-top:1px solid #eee; padding:8px 6px; }
    #hp-grid { display:grid; grid-template-columns: 1fr; gap:8px; }
    .hp-row { display:flex; align-items:center; gap:8px; }
    .hp-seat { width:36px; font-weight:700; text-align:center; }
    .hp-name { flex:1; min-width:0; color:#555; font-size:12px; }
    .hp-value { width:72px; text-align:right; }
    .hp-input { width:80px; padding:6px 8px; border:1px solid #ccc; border-radius:8px; text-align:right; }
    .hp-btn { padding:6px 10px; border:1px solid #ccc; border-radius:8px; background:#f6f6f6; cursor:pointer; }
    .hp-btn:disabled, .hp-input:disabled { opacity:.6; cursor:not-allowed; }
    
    

    #lobby{ position:fixed; inset:0; background:rgba(0,0,0,.58); display:flex; align-items:center; justify-content:center; z-index:9999; }
    .lobby-card{ width:min(920px, 96vw); background:#fff; border-radius:16px; box-shadow:0 10px 30px rgba(0,0,0,.35); padding:18px; box-sizing:border-box; }
    .lobby-grid{ display:grid; grid-template-columns: 1.15fr 1fr; gap:14px; }
    .lobby-title{ font-size:20px; font-weight:700; margin:4px 0 12px; text-align:center; }
    .lobby-section{ border:1px solid #e3e3e3; border-radius:12px; padding:12px; }
    .lobby-label{ display:block; font-size:12px; color:#555; margin-bottom:6px; }
    .lobby-subtitle{ font-weight:700; margin:0 0 8px; }
    .row{ display:flex; gap:8px; align-items:center; }
    .field{ flex:1; padding:10px 12px; font-size:16px; border:1px solid #bbb; border-radius:10px; }
    .btn{ padding:10px 12px; border-radius:10px; border:0; background:#0a7; color:#fff; font-weight:700; cursor:pointer; opacity:.95; }
    .btn:disabled{ background:#9ab; cursor:not-allowed; opacity:.7; }
    .btn.secondary{ background:#eee; color:#333; border:1px solid #ccc; }
    .seat-grid{ display:grid; grid-template-columns:repeat(4, 1fr); gap:8px; margin-top:8px; }
    .seat-btn{ padding:12px 0; border-radius:10px; border:1px solid #bbb; background:#fafafa; cursor:pointer; font-weight:600; position:relative; }
    .seat-btn.active{ outline:3px solid #0a7; background:#e9fff7; }
    .seat-btn[disabled]{ background:#eee; color:#888; border-color:#ddd; cursor:not-allowed; }
    .seat-note{ position:absolute; inset:auto 8px 6px auto; font-size:10px; color:#666; }
    .room-list{ max-height:320px; overflow:auto; border:1px solid #e5e5e5; border-radius:10px; }
    .room-item{ display:flex; align-items:center; justify-content:space-between; padding:10px 12px; border-bottom:1px solid #f0f0f0; }
    .room-item:last-child{ border-bottom:0; }
    .room-id{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:13px; }
    #spacer{ height:40px; clear:both; }
    .player-label { position: absolute; top: 6px; left: 6px; font-size: 22px; font-weight: bold; color: rgba(255, 255, 255, 0.95); background: rgba(0, 0, 0, 0.4); padding: 2px 8px; border-radius: 4px; pointer-events: none; z-index: 10; }
    .zone-label { position: absolute; right: 4px; bottom: 4px; font-size: 12px; font-weight: bold; color: rgba(255, 255, 255, 0.95); background: rgba(0, 0, 0, 0.4); padding: 1px 6px; border-radius: 4px; pointer-events: none; z-index: 5; }
    .deck-area, .main-play-area, .hand-area { position: relative; }
    #create-seat-grid .seat-btn.active{ outline: 3px solid #0a7; background: #e9fff7; box-shadow: 0 0 0 3px rgba(0,170,119,.15) inset; }
    #create-seat-picked { margin-top: 6px; font-size: 12px; color: #0a7; font-weight: 700; }
    .seat-btn:focus-visible{ outline: 3px solid #66aaff; }
    
    /* ã‚µã‚¤ãƒ‰ãƒãƒ¼ã‚’ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å¯èƒ½ã« */
#sidebar{
  overflow: auto;
  overscroll-behavior: contain;         /* ç”»é¢å…¨ä½“ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã«ä¼æ’­ã—ãªã„ */
  -webkit-overflow-scrolling: touch;    /* ãƒ¢ãƒã‚¤ãƒ«ã§æ…£æ€§ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ« */
}


    
    /* è¿½åŠ : ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ç”¨ï¼ˆå°ã•ãã¦ä¸¸ï¼‰ */
.card.counter{
  width:60px;
  height:60px;
  border-radius:50%;
  overflow:hidden;        /* ç”»åƒã¯å††å½¢ã«åˆ‡ã‚ŠæŠœã */
}
.card.counter img{
  border-radius:50%;
  object-fit:cover;
}
    
  </style>
</head>
<body>
  <h1>
    ç”»åƒã§éŠã¹ã‚‹ã‚«ãƒ¼ãƒ‰ãƒ‡ãƒƒã‚­ã‚²ãƒ¼ãƒ ï¼ˆ4äººç”¨ï¼‰
    <span id="session-indicator">ROOM: - / PLAYER: -</span>
  </h1>

  <div id="lobby" aria-modal="true" role="dialog">
    <div class="lobby-card">
      <div class="lobby-title">ãƒ—ãƒ¬ã‚¤ã‚¢ãƒ©ã‚¦ãƒ³ãƒ‰ã¸ã‚ˆã†ã“ã</div>
      <div class="lobby-grid">
        <!-- å·¦ï¼šæ—¢å­˜ãƒ«ãƒ¼ãƒ ã«å‚åŠ ï¼ˆéãƒ›ã‚¹ãƒˆï¼‰ -->
        <section class="lobby-section">
          <div class="lobby-subtitle">æ—¢å­˜ãƒ«ãƒ¼ãƒ ã«å‚åŠ ï¼ˆéãƒ›ã‚¹ãƒˆï¼‰</div>
          <label class="lobby-label">å‚åŠ ã™ã‚‹ãƒ«ãƒ¼ãƒ ID</label>
          <div class="row" style="margin-bottom:8px;">
            <input id="join-room-id" type="text" class="field" placeholder="ä¾‹: room-alpha / 1234" />
          </div>

          <label class="lobby-label">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å / è‰²</label>
          <div class="row" style="margin-bottom:8px;">
            <input id="player-name" type="text" class="field" maxlength="24" placeholder="åå‰ï¼ˆä¾‹: Aliceï¼‰" />
            <input id="player-color" type="color" value="#22aaff" title="ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚«ãƒ©ãƒ¼" />
          </div>

          <label class="lobby-label">åº§å¸­ã‚’é¸æŠ</label>
          <div class="seat-grid">
            <button class="seat-btn" data-seat="1">P1 <span class="seat-note"></span></button>
            <button class="seat-btn" data-seat="2">P2 <span class="seat-note"></span></button>
            <button class="seat-btn" data-seat="3">P3 <span class="seat-note"></span></button>
            <button class="seat-btn" data-seat="4">P4 <span class="seat-note"></span></button>
          </div>

          <div class="row" style="margin-top:10px; justify-content:flex-end; gap:8px;">
            <button id="start-btn" type="button" class="btn" disabled>é–‹å§‹</button>
            <button id="clear-btn" type="button" class="btn secondary">ã‚¯ãƒªã‚¢</button>
          </div>
        </section>

        <!-- å³ï¼šæ–°ã—ã„ãƒ«ãƒ¼ãƒ ã‚’ä½œæˆã—ã¦å‚åŠ ï¼ˆãƒ›ã‚¹ãƒˆï¼‰ -->
        <section class="lobby-section">
          <div class="lobby-subtitle">æ–°ã—ã„ãƒ«ãƒ¼ãƒ ã‚’ä½œæˆã—ã¦å‚åŠ ï¼ˆãƒ›ã‚¹ãƒˆï¼‰</div>

          <label class="lobby-label">æ–°ã—ã„ãƒ«ãƒ¼ãƒ ã‚’ä½œæˆ</label>
          <div class="row" style="margin-bottom:8px;">
            <input id="new-room-id" type="text" class="field" placeholder="ä½œæˆã™ã‚‹IDï¼ˆä¾‹: room-xyzï¼‰" />
          </div>
          <div class="row" style="margin-bottom:12px;">
            <input id="new-room-title" type="text" class="field" placeholder="ã‚¿ã‚¤ãƒˆãƒ«ï¼ˆä»»æ„ï¼‰" />
            <button id="create-room-btn" class="btn">ä½œæˆ</button>
          </div>

          <label class="lobby-label">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å / è‰²</label>
          <div class="row" style="margin-bottom:12px;">
            <input id="new-player-name" type="text" class="field" maxlength="24" placeholder="åå‰ï¼ˆä¾‹: Aliceï¼‰" />
            <input id="new-player-color" type="color" value="#22aaff" title="ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚«ãƒ©ãƒ¼" />
          </div>

          <label class="lobby-label">å…¬é–‹è¨­å®š</label>
          <div class="row" style="gap:12px; margin-bottom:12px;">
            <label class="row" style="gap:6px; align-items:center;">
              <input type="radio" name="room-visibility" id="room-public" value="public" checked />
              <span>å…¬é–‹</span>
            </label>
            <label class="row" style="gap:6px; align-items:center;">
              <input type="radio" name="room-visibility" id="room-private" value="private" />
              <span>éå…¬é–‹</span>
            </label>
          </div>

          <label class="lobby-label">ä½œæˆå¾Œã«å‚åŠ ã™ã‚‹åº§å¸­</label>
          <div class="seat-grid" id="create-seat-grid">
            <div id="create-seat-picked">æœªé¸æŠ</div>
            <button class="seat-btn" data-create-seat="1">P1</button>
            <button class="seat-btn" data-create-seat="2">P2</button>
            <button class="seat-btn" data-create-seat="3">P3</button>
            <button class="seat-btn" data-create-seat="4">P4</button>
          </div>

          <label class="lobby-label" style="margin-top:10px;">å…¬é–‹ãƒ«ãƒ¼ãƒ ä¸€è¦§ï¼ˆæ–°ã—ã„é †ï¼‰</label>
          <div id="room-list" class="room-list"></div>
        </section>
      </div>
    </div>
  </div>

  <div id="upload-area">
    ğŸ“¥ ã‚«ãƒ¼ãƒ‰ç”»åƒã‚’ã‚¯ãƒªãƒƒã‚¯ or ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—ã§è¿½åŠ 
    <input type="file" id="file-input" multiple accept="image/*" />
  </div>

  <div id="sidebar">
    <h2>æ“ä½œãƒ‘ãƒãƒ«</h2>
    <!-- è¿½åŠ : å…¨ã‚«ãƒ¼ãƒ‰å‘ããƒªã‚»ãƒƒãƒˆï¼ˆè‡ªåˆ†ã®ã‚«ãƒ¼ãƒ‰ã®ã¿ï¼‰ -->
    <button onclick="resetMyCardRotation()">â†» å…¨ã‚«ãƒ¼ãƒ‰å‘ããƒªã‚»ãƒƒãƒˆï¼ˆè‡ªåˆ†ã®ã‚«ãƒ¼ãƒ‰ã®ã¿ï¼‰</button>
    <button onclick="faceDownAll()">ğŸ‚  è£è¿”ã™ï¼ˆè‡ªåˆ†ã®ã‚«ãƒ¼ãƒ‰ã®ã¿ï¼‰</button>
    <button onclick="faceUpAll()">ğŸ‚¡ è¡¨ã«ã™ã‚‹ï¼ˆè‡ªåˆ†ã®ã‚«ãƒ¼ãƒ‰ã®ã¿ï¼‰</button>
    <button onclick="shuffleDecks()">ğŸŒ€ ã‚·ãƒ£ãƒƒãƒ•ãƒ«ï¼ˆè‡ªåˆ†ã®ãƒ‡ãƒƒã‚­ã®ã¿ï¼‰</button>
    <button onclick="openMyCardsDialog()">ğŸ—‚ å…¨ã‚«ãƒ¼ãƒ‰ä¸€è¦§ï¼ˆè‡ªåˆ†ï¼‰</button>
    <button onclick="spawnCounter('+1')">â• +1ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼</button>
    <button onclick="spawnCounter('+10')">â• +10ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼</button>
    <button onclick="spawnCounter('-1')">â– -1ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼</button>
    <button onclick="spawnCounter('-10')">â– -10ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼</button>
    <button onclick="deleteMyCards()">ğŸ—‘ å…¨ã‚«ãƒ¼ãƒ‰å‰Šé™¤ï¼ˆè‡ªåˆ†ã®ã‚«ãƒ¼ãƒ‰ã®ã¿ï¼‰</button>
    <button onclick="alignDecks()">ğŸ“ æ•´åˆ—ï¼ˆè¡¨ç¤ºã®ã¿ï¼‰</button>

    <button onclick="toggleFieldSizeOptions()">ğŸ–¼ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚µã‚¤ã‚ºå¤‰æ›´</button>
    <div id="field-size-options">
      <button onclick="setFieldSize('small')">å°</button>
      <button onclick="setFieldSize('medium')">ä¸­</button>
      <button onclick="setFieldSize('large')">å¤§</button>
    </div>
    
    <!-- è¿½åŠ : ãƒ›ã‚¹ãƒˆå°‚ç”¨ã€Œãƒ«ãƒ¼ãƒ ã‚’çµ‚äº†ã€ãƒœã‚¿ãƒ³ï¼ˆåˆæœŸã¯éè¡¨ç¤ºï¼‰ -->
    <button id="end-room-btn" class="danger" style="display:none">ğŸšª ãƒ«ãƒ¼ãƒ ã‚’çµ‚äº†ï¼ˆãƒ›ã‚¹ãƒˆï¼‰</button>
    
  </div>

  <div id="container">
    <div id="field">
      <div class="player-area player-1">
        <div class="player-label"><span class="label-seat">P1</span> <span class="label-name"></span></div>
        <div class="play-area">
          <div class="deck-area"><div class="zone-label">ãƒ‡ãƒƒã‚­ã‚¨ãƒªã‚¢</div></div>
          <div class="main-play-area"><div class="zone-label">ãƒ—ãƒ¬ã‚¤ã‚¨ãƒªã‚¢</div></div>
        </div>
        <div class="hand-area"><div class="zone-label">æ‰‹æœ­ã‚¨ãƒªã‚¢</div></div>
      </div>
      <div class="player-area player-2">
        <div class="player-label"><span class="label-seat">P2</span> <span class="label-name"></span></div>
        <div class="play-area">
          <div class="deck-area"><div class="zone-label">ãƒ‡ãƒƒã‚­ã‚¨ãƒªã‚¢</div></div>
          <div class="main-play-area"><div class="zone-label">ãƒ—ãƒ¬ã‚¤ã‚¨ãƒªã‚¢</div></div>
        </div>
        <div class="hand-area"><div class="zone-label">æ‰‹æœ­ã‚¨ãƒªã‚¢</div></div>
      </div>
      <div class="player-area player-3">
        <div class="player-label"><span class="label-seat">P3</span> <span class="label-name"></span></div>
        <div class="play-area">
          <div class="deck-area"><div class="zone-label">ãƒ‡ãƒƒã‚­ã‚¨ãƒªã‚¢</div></div>
          <div class="main-play-area"><div class="zone-label">ãƒ—ãƒ¬ã‚¤ã‚¨ãƒªã‚¢</div></div>
        </div>
        <div class="hand-area"><div class="zone-label">æ‰‹æœ­ã‚¨ãƒªã‚¢</div></div>
      </div>
      <div class="player-area player-4">
        <div class="player-label"><span class="label-seat">P4</span> <span class="label-name"></span></div>
        <div class="play-area">
          <div class="deck-area"><div class="zone-label">ãƒ‡ãƒƒã‚­ã‚¨ãƒªã‚¢</div></div>
          <div class="main-play-area"><div class="zone-label">ãƒ—ãƒ¬ã‚¤ã‚¨ãƒªã‚¢</div></div>
        </div>
        <div class="hand-area"><div class="zone-label">æ‰‹æœ­ã‚¨ãƒªã‚¢</div></div>
      </div>
    </div>
  </div>

  <div id="preview">
    <div id="preview-top">
      <h2>é¸æŠä¸­ã®ã‚«ãƒ¼ãƒ‰</h2>
      <img id="preview-img" src="" alt="ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”»åƒ" />
      <div id="preview-info"></div>
    </div>
    <!-- è¿½åŠ : HP ãƒ‘ãƒãƒ«ï¼ˆä¸‹1/3ï¼‰ -->
    <div id="hp-panel" aria-label="HP ãƒ‘ãƒãƒ«">
      <div style="font-size:12px;color:#666;margin-bottom:6px;">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼HP</div>
      <div id="hp-grid"><!-- JSã§P1ã€œP4è¡Œã‚’æç”» --></div>
    </div>
  </div>


  <div id="spacer"></div>
  
  <!-- å…¨ã‚«ãƒ¼ãƒ‰ä¸€è¦§ãƒ¢ãƒ¼ãƒ€ãƒ« -->
<div id="card-list-modal" role="dialog" aria-modal="true" aria-labelledby="card-list-title" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.55); align-items:center; justify-content:center; z-index:10000;">
  <div id="card-list-sheet" style="width:min(920px, 92vw); max-height:80vh; background:#fff; border-radius:14px; box-shadow:0 10px 30px rgba(0,0,0,.35); overflow:hidden; display:flex; flex-direction:column;">
    <div id="card-list-header" style="padding:10px 12px; display:flex; align-items:center; justify-content:space-between; border-bottom:1px solid #eee;">
      <div id="card-list-title" style="font-weight:700;">è‡ªåˆ†ã®ã‚«ãƒ¼ãƒ‰ä¸€è¦§</div>
      <button id="card-list-close" type="button" style="border:0; background:#eee; padding:6px 10px; border-radius:8px; cursor:pointer;">é–‰ã˜ã‚‹</button>
    </div>
    <div id="card-list-body" style="padding:12px; overflow:auto;">
      <div id="card-list-grid" style="display:grid; grid-template-columns:repeat(auto-fill, minmax(96px, 1fr)); gap:10px;"></div>
    </div>
  </div>
</div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-auth.js";
    import { getFirestore, doc, setDoc, onSnapshot, serverTimestamp, runTransaction, deleteDoc, collection, limit, addDoc, updateDoc, where, query, getDocs, writeBatch } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "AIzaSyCy-r6L1NgyHcqvsfpkyNPDJq9uMvv2CMM",
      authDomain: "cardgame-f484c.firebaseapp.com",
      projectId: "cardgame-f484c",
      storageBucket: "cardgame-f484c.firebasestorage.app",
      messagingSenderId: "248859224605",
      appId: "1:248859224605:web:1320093856bc1861c174f4"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    const lobby = document.getElementById('lobby');
    const joinRoomInput = document.getElementById('join-room-id');
    const playerNameInput = document.getElementById('player-name');
    const playerColorInput = document.getElementById('player-color');
    const seatButtons = Array.from(document.querySelectorAll('.seat-grid:not(#create-seat-grid) .seat-btn'));
    const startBtn = document.getElementById('start-btn');
    const clearBtn = document.getElementById('clear-btn');
    const sessionIndicator = document.getElementById('session-indicator');

    const newRoomIdInput = document.getElementById('new-room-id');
    const newRoomTitleInput = document.getElementById('new-room-title');
    const newPlayerNameInput = document.getElementById('new-player-name');
    const newPlayerColorInput = document.getElementById('new-player-color');
    const createRoomBtn = document.getElementById('create-room-btn');
    const roomListDiv = document.getElementById('room-list');

    const createSeatButtons = Array.from(document.querySelectorAll('#create-seat-grid .seat-btn'));
    let CREATE_SELECTED_SEAT = null;
    createSeatButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        CREATE_SELECTED_SEAT = parseInt(btn.dataset.createSeat, 10);
        createSeatButtons.forEach(b => b.classList.toggle('active', b === btn));
        const picked = document.getElementById('create-seat-picked');
        if (picked) picked.textContent = `é¸æŠä¸­: P${CREATE_SELECTED_SEAT}`;
      });
    });

    let CURRENT_ROOM = null;
    let CURRENT_ROOM_META = null;
    let unsubscribeRoomDoc = null;
    let CURRENT_PLAYER = null; // 1..4
    let CURRENT_UID = null;
    let hostWatchTimer = null;

    let ACTIVE_MODE = 'join'; // 'join' | 'create'
    let IS_ROOM_CREATOR = false;

    // ã—ãã„å€¤ï¼ˆmsï¼‰
    const HOST_STALE_MS = 15000;
    const SEAT_STALE_MS = 60000;

    const CARD_W = 120;
    const CARD_H = 160;

    function isHostAlive(roomMeta){
      if(!roomMeta?.hostUid) return false;
      if (CURRENT_UID && roomMeta.hostUid === CURRENT_UID) return true; // è‡ªåˆ†ãŒãƒ›ã‚¹ãƒˆæœ¬äººãªã‚‰åœ¨å®¤æ‰±ã„
      const now = Date.now();
      const t = roomMeta.hostHeartbeatAt?.toMillis?.() ?? 0;
      if (now - t < HOST_STALE_MS) return true;
      const hostSeat = roomMeta.hostSeat;
      if (hostSeat) {
        const d = currentSeatMap[hostSeat];
        const hb = d?.heartbeatAt?.toMillis?.();
        if (hb && (now - hb) < SEAT_STALE_MS) return true;
      }
      for (const s of [1,2,3,4]) {
        const d = currentSeatMap[s];
        const hb = d?.heartbeatAt?.toMillis?.();
        if (d?.claimedByUid === roomMeta.hostUid && hb && (now - hb) < SEAT_STALE_MS) return true;
      }
      return false;
    }

    signInAnonymously(auth).catch(console.error);
    onAuthStateChanged(auth, (user) => { if(user){ CURRENT_UID = user.uid; }});

    // ãƒ¢ãƒ¼ãƒ‰åˆ‡æ›¿
    joinRoomInput.addEventListener('input', () => { ACTIVE_MODE = 'join'; validateLobby(); });
    playerNameInput.addEventListener('input', () => { ACTIVE_MODE = 'join'; validateLobby(); });
    seatButtons.forEach(btn => btn.addEventListener('click', () => { ACTIVE_MODE = 'join'; validateLobby(); }));

    newRoomIdInput.addEventListener('input', () => { ACTIVE_MODE = 'create'; validateLobby(); });
    newRoomTitleInput.addEventListener('input', () => { ACTIVE_MODE = 'create'; validateLobby(); });
    newPlayerNameInput.addEventListener('input', () => { ACTIVE_MODE = 'create'; validateLobby(); });
    newPlayerColorInput.addEventListener('input', () => { ACTIVE_MODE = 'create'; validateLobby(); });
    createSeatButtons.forEach(btn => btn.addEventListener('click', () => { ACTIVE_MODE = 'create'; validateLobby(); }));

    function isCenterInsideRect(x, y, rect){
      const cx = x + CARD_W / 2;
      const cy = y + CARD_H / 2;
      return cx >= rect.minX && cx <= rect.minX + rect.width && cy >= rect.minY && cy <= rect.minY + rect.height;
    }
    function getHandBoundsForSeat(seat){
      const hand = document.querySelector(`.player-${seat} .hand-area`);
      if(!hand) return null;
      const handRect  = hand.getBoundingClientRect();
      const fieldRect = field.getBoundingClientRect();
      const minX = (handRect.left - fieldRect.left) / zoom;
      const minY = (handRect.top  - fieldRect.top ) / zoom;
      const width  = handRect.width  / zoom;
      const height = handRect.height / zoom;
      return { minX, minY, width, height };
    }
    function getDeckBoundsForSeat(seat){
      const deck = document.querySelector(`.player-${seat} .deck-area`);
      if(!deck) return null;
      const deckRect  = deck.getBoundingClientRect();
      const fieldRect = field.getBoundingClientRect();
      const minX = (deckRect.left - fieldRect.left) / zoom;
      const minY = (deckRect.top  - fieldRect.top)  / zoom;
      const width  = deckRect.width  / zoom;
      const height = deckRect.height / zoom;
      return { minX, minY, width, height };
    }
    function getCardsInsideRect(rect){
      const cards = [];
      document.querySelectorAll('.card').forEach(el => {
        const id = el.dataset.cardId;
        const w = el.offsetWidth  || CARD_W; // â†è¦ç´ ã®å®Ÿã‚µã‚¤ã‚º
        const h = el.offsetHeight || CARD_H;
        const left = parseFloat(el.style.left) || 0;
        const top  = parseFloat(el.style.top)  || 0;
        const cx = left + CARD_W/2;
        const cy = top  + CARD_H/2;
        if(cx >= rect.minX && cx <= rect.minX + rect.width && cy >= rect.minY && cy <= rect.minY + rect.height){
          cards.push({ id, el });
        }
      });
      return cards;
    }
    function shuffleArray(arr){
      for(let i=arr.length-1;i>0;i--){
        const j = (Math.random()* (i+1))|0;
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }
    function randomPointInDeck(seat){
      const b = getDeckBoundsForSeat(seat);
      if(!b) return { x: Math.random()*500|0, y: Math.random()*500|0 };
      const maxX = Math.max(b.minX, b.minX + b.width  - CARD_W);
      const maxY = Math.max(b.minY, b.minY + b.height - CARD_H);
      const x = b.minX + Math.random() * (maxX - b.minX);
      const y = b.minY + Math.random() * (maxY - b.minY);
      return { x: Math.round(x), y: Math.round(y) };
    }

    function startHostWatch() {
      stopHostWatch();
      hostWatchTimer = setInterval(() => {
        if (!CURRENT_ROOM || lobby.style.display !== 'none') return;
        if (!CURRENT_ROOM_META) return;
        const iAmHost  = !!(CURRENT_ROOM_META?.hostUid && CURRENT_UID && CURRENT_ROOM_META.hostUid === CURRENT_UID);
        const closed   = !!CURRENT_ROOM_META?.roomClosed;
        const hostHere = isHostAlive(CURRENT_ROOM_META);
        if (!iAmHost && (closed || !hostHere)) {
          try { if (CURRENT_ROOM && CURRENT_PLAYER) releaseSeat(CURRENT_ROOM, CURRENT_PLAYER); } catch(_) {}
          if (unsubscribeCards) { unsubscribeCards(); unsubscribeCards = null; }
          if (unsubscribeSeats) { unsubscribeSeats(); unsubscribeSeats = null; }
          if (unsubscribeRoomDoc) { unsubscribeRoomDoc(); unsubscribeRoomDoc = null; }
          CURRENT_ROOM = null;
          CURRENT_PLAYER = null;
          stopHostWatch();
          sessionIndicator.textContent = 'ROOM: - / PLAYER: -';
          lobby.style.display = 'flex';
          alert('ãƒ›ã‚¹ãƒˆãŒé€€å®¤ã—ãŸãŸã‚ã€ã“ã®ãƒ«ãƒ¼ãƒ ã¯çµ‚äº†ã—ã¾ã—ãŸã€‚');
        }
      }, 3000);
    }
    function stopHostWatch() { if (hostWatchTimer) { clearInterval(hostWatchTimer); hostWatchTimer = null; } }

    function subscribeRoomList(){
      const qRooms = query(collection(db, 'rooms'), where('public', '==', true), limit(50));
      onSnapshot(qRooms, snap => {
        const docs = snap.docs.slice().sort((a,b) => {
          const au = a.data().updatedAt?.toMillis?.() ?? 0;
          const bu = b.data().updatedAt?.toMillis?.() ?? 0;
          return bu - au;
        });
        roomListDiv.innerHTML = '';
        docs.forEach(docSnap => {
          const data = docSnap.data() || {};
          const item = document.createElement('div');
          item.className = 'room-item';
          item.style.cursor = 'pointer';
          const left = document.createElement('div');
          left.innerHTML = `
            <div class="room-id">${docSnap.id}</div>
            <div style="font-size:12px; color:#555;">${(data.title||'ï¼ˆç„¡é¡Œï¼‰')}</div>
          `;
          const right = document.createElement('div');
          const btn = document.createElement('button');
          btn.setAttribute('type', 'button');
          btn.className = 'btn secondary';
          btn.textContent = 'å‚åŠ ';
          const selectRoom = (ev) => {
            if (ev) { ev.preventDefault(); ev.stopPropagation(); }
            joinRoomInput.value = docSnap.id;
            ACTIVE_MODE = 'join';
            loadSeatStatus();
            setTimeout(() => { joinRoomInput.focus(); joinRoomInput.scrollIntoView({behavior:'smooth', block:'center'}); }, 0);
          };
          btn.addEventListener('click', selectRoom);
          item.addEventListener('click', selectRoom);
          right.appendChild(btn);
          item.appendChild(left);
          item.appendChild(right);
          roomListDiv.appendChild(item);
        });
      });
    }
    subscribeRoomList();

    function ensureAuthReady(){
      return new Promise((resolve) => {
        if (CURRENT_UID) return resolve();
        const off = onAuthStateChanged(auth, (u) => { if (u) { CURRENT_UID = u.uid; off(); resolve(); } });
      });
    }

    // â”€â”€ CREATEï¼ˆå³ï¼‰ï¼šä½œæˆâ†’å³å‚åŠ ï¼ˆãƒ›ã‚¹ãƒˆï¼‰
    createRoomBtn.addEventListener('click', async () => {
      ACTIVE_MODE = 'create';
      await ensureAuthReady();

      const id = (newRoomIdInput.value||'').trim();
      const title = (newRoomTitleInput.value||'').trim();
      const isPublic = document.getElementById('room-public').checked;
      const creatorName  = (newPlayerNameInput.value || '').trim();
      const creatorColor = (newPlayerColorInput.value || '#22aaff');

      if(!id){ alert('ãƒ«ãƒ¼ãƒ IDã‚’å…¥åŠ›ã—ã¦ãã ã•ã„'); return; }
      if(!creatorName){ alert('ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„'); newPlayerNameInput.focus(); return; }
      if(!CREATE_SELECTED_SEAT){ alert('ä½œæˆå¾Œã«å‚åŠ ã™ã‚‹åº§å¸­ã‚’é¸ã‚“ã§ãã ã•ã„'); return; }

      try{
        await setDoc(doc(db, `rooms/${id}`), {
          title: title || null,
          createdAt: serverTimestamp(),
          updatedAt: serverTimestamp(),
          public: !!isPublic,
          hostUid: CURRENT_UID,
          hostDisplayName: creatorName
        }, { merge: true });

        IS_ROOM_CREATOR = true;
        startHostHeartbeat(id); // ãƒ­ãƒ“ãƒ¼ä¸­ã‹ã‚‰HB

        // æ¥½è¦³åæ˜ 
        CURRENT_ROOM_META = { ...(CURRENT_ROOM_META||{}), hostUid: CURRENT_UID, hostDisplayName: creatorName };
        renderFieldLabels();

        playerNameInput.value  = creatorName;
        playerColorInput.value = creatorColor;

        // åº§å¸­ç¢ºä¿ â†’ å³é–‹å§‹
        joinRoomInput.value = id;
        loadSeatStatus();

        const ok = await claimSeat(id, CREATE_SELECTED_SEAT);
        if(!ok){ alert(`P${CREATE_SELECTED_SEAT} ã¯ä½¿ç”¨ä¸­ã§ã—ãŸã€‚åˆ¥ã®åº§å¸­ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚`); return; }

        await setDoc(doc(db, `rooms/${id}`), { hostSeat: CREATE_SELECTED_SEAT, updatedAt: serverTimestamp() }, { merge: true });

        currentSeatMap[CREATE_SELECTED_SEAT] = {
          ...(currentSeatMap[CREATE_SELECTED_SEAT] || {}),
          claimedByUid: CURRENT_UID,
          displayName: creatorName
        };
        renderFieldLabels();

        CURRENT_PLAYER = CREATE_SELECTED_SEAT;
        seatButtons.forEach(b => b.classList.toggle('active', parseInt(b.dataset.seat,10) === CURRENT_PLAYER));
        startSession(id, CREATE_SELECTED_SEAT);
      }catch(e){
        console.error(e);
        alert('ãƒ«ãƒ¼ãƒ ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸ');
      }
    });

    let unsubscribeSeats = null;
    joinRoomInput.addEventListener('change', loadSeatStatus);
    joinRoomInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') loadSeatStatus(); });

    playerNameInput.addEventListener('change', async () => {
      const newName = (playerNameInput.value || '').trim();
      if (!CURRENT_ROOM || !CURRENT_PLAYER || !CURRENT_UID) return;
      const seatRef = doc(db, `rooms/${CURRENT_ROOM}/seats/${CURRENT_PLAYER}`);
      await setDoc(seatRef, { displayName: newName, updatedAt: serverTimestamp() }, { merge: true });
    });

    const currentSeatMap = {1:null,2:null,3:null,4:null};
    function isSeatStale(data){
      if(!data || !data.heartbeatAt) return true;
      const hb = data.heartbeatAt?.toMillis ? data.heartbeatAt.toMillis() : 0;
      return (Date.now() - hb) > SEAT_STALE_MS;
    }

    function renderSeatAvailability(){
      const hostHere = isHostAlive(CURRENT_ROOM_META);
      seatButtons.forEach(btn => {
        const seat = parseInt(btn.dataset.seat, 10);
        const note = btn.querySelector('.seat-note');
        const data = currentSeatMap[seat];

        if(!hostHere){
          note.textContent = 'ãƒ›ã‚¹ãƒˆä¸åœ¨';
          note.style.color = 'red';
          btn.disabled = true;
          btn.classList.toggle('active', false);
          return;
        }

        const occupied = !!(data && !isSeatStale(data) && data.claimedByUid);
        if (occupied) {
          const isHostSeat = (CURRENT_ROOM_META?.hostSeat === seat);
          note.textContent = (data.displayName || '') + (isHostSeat ? 'ï¼ˆãƒ›ã‚¹ãƒˆï¼‰' : '');
          note.style.color = '#000';
        } else {
          note.textContent = 'ç©ºã';
          note.style.color = 'blue';
        }
        btn.disabled = occupied;
        btn.classList.toggle('active', CURRENT_PLAYER === seat);
      });

      renderFieldLabels();
      validateLobby();
      updateEndRoomButtonVisibility(); // è¿½åŠ 
      renderAreaColors(); // è¿½åŠ : ã‚¨ãƒªã‚¢è‰²åæ˜ 
      renderHPPanel(); // è¿½åŠ : HPå†æç”»
      
    }
    
    
    // è¿½åŠ : HPãƒ‘ãƒãƒ«æç”» & è‡ªå¸­ã®ã¿ç·¨é›†å¯
    function renderHPPanel(){
      const grid = document.getElementById('hp-grid');
      if (!grid) return;
      const rows = [];
      for (const seat of [1,2,3,4]) {
        const seatData = currentSeatMap[seat] || {};
        const dispName = seatData.displayName || '';
        const isMe = (CURRENT_PLAYER === seat);
        const hpVal = (typeof seatData.hp === 'number') ? seatData.hp : 0;
        rows.push(`
          <div class="hp-row" data-seat="${seat}">
            <div class="hp-seat">P${seat}</div>
            <div class="hp-name">${dispName ? dispName : ''}</div>
            <div class="hp-value">
              <input class="hp-input" type="number" step="1" value="${hpVal}" ${isMe ? '' : 'disabled'} />
            </div>
            <div class="hp-ops">
              <button class="hp-btn hp-minus" ${isMe ? '' : 'disabled'}>-</button>
              <button class="hp-btn hp-plus"  ${isMe ? '' : 'disabled'}>+</button>
            </div>
          </div>
        `);
      }
      grid.innerHTML = rows.join('');
      grid.querySelectorAll('.hp-row').forEach(row => {
        const seat = parseInt(row.dataset.seat, 10);
        if (seat !== CURRENT_PLAYER) return; // è‡ªåˆ†ä»¥å¤–ã¯ç·¨é›†ä¸å¯
        const input = row.querySelector('.hp-input');
        const minus = row.querySelector('.hp-minus');
        const plus  = row.querySelector('.hp-plus');
        const commit = async (nextVal) => {
          const n = Number.isFinite(nextVal) ? Math.trunc(nextVal) : 0;
          if (input) input.value = n;
          try {
            const seatRef = doc(db, `rooms/${CURRENT_ROOM}/seats/${seat}`);
            await setDoc(seatRef, { hp: n, updatedAt: serverTimestamp() }, { merge: true });
          } catch(e) {
            console.error(e);
            alert('HPã®æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚’ã”ç¢ºèªãã ã•ã„ã€‚');
          }
        };
        input?.addEventListener('change', () => commit(parseInt(input.value, 10)));
        minus?.addEventListener('click', () => commit(parseInt(input.value, 10) - 1));
        plus ?.addEventListener('click', () => commit(parseInt(input.value, 10) + 1));
      });
    }
    
    
    // ===== è¿½åŠ : ã‚¨ãƒªã‚¢è‰²ã®åæ˜ ã¨ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ç·¨é›† =====
    function getSeatAreaColor(seat, zone){
      const ac = currentSeatMap[seat]?.areaColors || {};
      return ac[zone] || DEFAULT_AREA_COLORS[zone];
    }

    function renderAreaColors(){
      for (const seat of [1,2,3,4]) {
        const root = document.querySelector(`.player-${seat}`);
        if (!root) continue;
        const deck = root.querySelector('.deck-area');
        const main = root.querySelector('.main-play-area');
        const hand = root.querySelector('.hand-area');
        if (deck) deck.style.background = getSeatAreaColor(seat, 'deck');
        if (main) main.style.background = getSeatAreaColor(seat, 'main');
        if (hand) hand.style.background = getSeatAreaColor(seat, 'hand');
      }
    }

    // è‡ªåˆ†ã®åº§å¸­ã®å„ã‚¨ãƒªã‚¢ã‚’ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã§è‰²å¤‰æ›´ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹
    function bindAreaColorHandlers(){
      for (const seat of [1,2,3,4]) {
        const root = document.querySelector(`.player-${seat}`);
        if (!root) continue;
        const zones = [
          { el: root.querySelector('.deck-area'), key: 'deck' },
          { el: root.querySelector('.main-play-area'), key: 'main' },
          { el: root.querySelector('.hand-area'), key: 'hand' },
        ];
        zones.forEach(({el, key}) => {
          if (!el) return;
          if (el.__colorHandlerBound) return;
          el.__colorHandlerBound = true;
          // ãƒ‘ãƒ³å´ã®åˆ¤å®šç”¨ã€‚è¦‹ãŸç›®ã®ãƒ’ãƒ³ãƒˆã‚‚ä»˜ã‘ã‚‹
          el.classList.add('zone-colorable');
          el.style.cursor = 'pointer';
          
          
          el.addEventListener('dblclick', async (ev) => {
            ev.stopPropagation();            
            if (seat !== CURRENT_PLAYER) return;
            if (!CURRENT_ROOM) return;
            const input = document.createElement('input');
            input.type = 'color';
            input.value = getSeatAreaColor(seat, key);
            input.style.position = 'fixed';
            input.style.left = '-9999px';
            document.body.appendChild(input);
            input.addEventListener('change', async () => {
              const picked = input.value;
              el.style.background = picked;
              try{
                const prev = (currentSeatMap[seat]?.areaColors) || {};
                const next = { ...prev, [key]: picked };
                const seatRef = doc(db, `rooms/${CURRENT_ROOM}/seats/${seat}`);
                await setDoc(seatRef, { areaColors: next, updatedAt: serverTimestamp() }, { merge: true });
              }catch(err){
                console.error(err);
                alert('ã‚¨ãƒªã‚¢è‰²ã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚’ã”ç¢ºèªãã ã•ã„ã€‚');
              }
              input.remove(); // ãƒ”ãƒƒã‚«ãƒ¼ã‚’é–‰ã˜ãŸå¾Œã«ç‰‡ä»˜ã‘
            }, { once: true });
            
            input.click();
          });
        });
      }
    }
    
    
    
    

    function renderFieldLabels(){
      for (const s of [1,2,3,4]) {
        const area   = document.querySelector(`.player-${s}`);
        const seatEl = area?.querySelector('.player-label .label-seat');
        const nameEl = area?.querySelector('.player-label .label-name');
        if(!seatEl || !nameEl) continue;

        seatEl.textContent = `P${s}`;
        const seatData = currentSeatMap[s] || null;
        const displayName = seatData?.displayName || '';
        const isHostSeat = (CURRENT_ROOM_META?.hostSeat === s);
        nameEl.textContent = displayName ? `${displayName}${isHostSeat ? 'ï¼ˆãƒ›ã‚¹ãƒˆï¼‰' : ''}` : '';
      }
    }

    function detachSeatsListener(){ if(unsubscribeSeats){ unsubscribeSeats(); unsubscribeSeats = null; } }

    function loadSeatStatus(){
      detachSeatsListener();
      if (unsubscribeRoomDoc) { unsubscribeRoomDoc(); unsubscribeRoomDoc = null; }
      const roomId = (joinRoomInput.value||'').trim();

      CURRENT_ROOM_META = null;
      IS_ROOM_CREATOR = false;
      stopHostHeartbeat();
      stopHostWatch();
      renderFieldLabels();

      if(!roomId){ return; }

      // ãƒ«ãƒ¼ãƒ docè³¼èª­
      unsubscribeRoomDoc = onSnapshot(doc(db, `rooms/${roomId}`), snap => {
        CURRENT_ROOM_META = snap.exists() ? snap.data() : null;
        IS_ROOM_CREATOR = !!(CURRENT_ROOM_META?.hostUid && CURRENT_UID && CURRENT_ROOM_META.hostUid === CURRENT_UID);
        if (IS_ROOM_CREATOR) startHostHeartbeat(roomId);
        renderFieldLabels();
        renderAreaColors(); // è¿½åŠ : ã‚¨ãƒªã‚¢è‰²åæ˜ 
        updateEndRoomButtonVisibility(); // è¿½åŠ 
        renderHPPanel(); // è¿½åŠ : HPå†æç”»
      });

      // è»½ãæ›´æ–°æ™‚åˆ»ã ã‘
      setDoc(doc(db, `rooms/${roomId}`), { updatedAt: serverTimestamp() }, { merge: true }).catch(()=>{});

      // åº§å¸­docè³¼èª­
      const seatDocs = [1,2,3,4].map(n => doc(db, `rooms/${roomId}/seats/${n}`));
      const unsubs = seatDocs.map((ref, idx) => onSnapshot(ref, snap => {
        currentSeatMap[idx+1] = snap.exists() ? snap.data() : null;
        renderAreaColors(); // è¿½åŠ : ã‚¨ãƒªã‚¢è‰²åæ˜ 
        renderSeatAvailability();
        // renderHPPanel ã¯ renderSeatAvailability å†…ã§å‘¼ã°ã‚Œã‚‹
      }));
      unsubscribeSeats = () => unsubs.forEach(fn => fn());
    }

    function validateLobby(){
      const hostHere = isHostAlive(CURRENT_ROOM_META);
      if (!hostHere && ACTIVE_MODE === 'join') { startBtn.disabled = true; return; }
      if (ACTIVE_MODE === 'create') { startBtn.disabled = true; return; }
      const roomOk  = !!(joinRoomInput.value||'').trim();
      const nameNow = (playerNameInput.value||'').trim();
      const nameOk  = nameNow.length > 0 && nameNow.length <= 24;
      const seatOk  = !!CURRENT_PLAYER;
      startBtn.disabled = !(roomOk && nameOk && seatOk);
    }

    seatButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        ACTIVE_MODE = 'join';
        let nameNow = (playerNameInput.value || '').trim();
        if (!nameNow) {
          const rightName  = (newPlayerNameInput.value || '').trim();
          const rightColor = (newPlayerColorInput.value || '');
          if (rightName) {
            playerNameInput.value  = rightName;
            if (rightColor) playerColorInput.value = rightColor;
            nameNow = rightName;
          }
        }
        if (!nameNow) { alert('å…ˆã«ã€Œãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åã€ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚'); playerNameInput.focus(); return; }
        const seat = parseInt(btn.dataset.seat, 10);
        CURRENT_PLAYER = seat;
        seatButtons.forEach(b => b.classList.toggle('active', parseInt(b.dataset.seat,10) === CURRENT_PLAYER));
        validateLobby();
        updateEndRoomButtonVisibility(); // è¿½åŠ 
        renderHPPanel(); // è¿½åŠ 
      });
    });

    clearBtn.addEventListener('click', () => {
      joinRoomInput.value = '';
      CURRENT_PLAYER = null;
      renderSeatAvailability();
      detachSeatsListener();
      joinRoomInput.focus();
      updateEndRoomButtonVisibility(); // è¿½åŠ 
      renderHPPanel(); // è¿½åŠ 
    });

    startBtn.addEventListener('click', async (ev) => {
      ev.preventDefault();
      ACTIVE_MODE = 'join';
      await ensureAuthReady();
      if (!CURRENT_UID) { alert('èªè¨¼ã®åˆæœŸåŒ–ã«æ™‚é–“ãŒã‹ã‹ã£ã¦ã„ã¾ã™ã€‚æ•°ç§’å¾Œã«å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚'); return; }

      const room    = (joinRoomInput.value || '').trim();
      const seat    = CURRENT_PLAYER;
      const nameNow = (playerNameInput.value || '').trim();
      const colorNow = playerColorInput.value || '#22aaff';

      if (!room)  { alert('ãƒ«ãƒ¼ãƒ IDã‚’å…¥åŠ›ã—ã¦ãã ã•ã„'); return; }
      if (!nameNow) { alert('ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„'); return; }
      if (!seat)  { alert('åº§å¸­ã‚’é¸æŠã—ã¦ãã ã•ã„'); return; }

      const oldText = startBtn.textContent;
      startBtn.disabled = true;
      startBtn.textContent = 'é–‹å§‹ä¸­â€¦';

      try {
        const roomSnap = await onSnapshotOnce(doc(db, `rooms/${room}`));
        const meta = roomSnap.exists() ? roomSnap.data() : null;
        const iAmHost = !!(meta?.hostUid && CURRENT_UID && meta.hostUid === CURRENT_UID);

        // hostUid ãŒã‚ã‚Œã°å…¥å®¤è¨±å¯ï¼ˆå…¥å®¤å¾Œã®ç›£è¦–ã§æœ€çµ‚åˆ¤å®šï¼‰
        const hostLikelyHere = !!meta?.hostUid || isHostAlive(meta);
        if (!meta || (!hostLikelyHere && !iAmHost)) { alert('ãƒ›ã‚¹ãƒˆãŒä¸åœ¨ã®ãŸã‚ã€ã“ã®ãƒ«ãƒ¼ãƒ ã«ã¯å‚åŠ ã§ãã¾ã›ã‚“ã€‚'); return; }
        if (iAmHost) IS_ROOM_CREATOR = true;

        const ok = await claimSeat(room, seat);
        if (!ok) { alert('é–‹å§‹ç›´å‰ã«åº§å¸­ãŒåŸ‹ã¾ã‚Šã¾ã—ãŸã€‚åˆ¥ã®å¸­ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚'); return; }

        currentSeatMap[seat] = { ...(currentSeatMap[seat] || {}), claimedByUid: CURRENT_UID, displayName: nameNow, color: colorNow };
        renderSeatAvailability();

        startSession(room, seat);
      } catch (e) {
        console.error(e);
        alert('é–‹å§‹ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯çŠ¶æ…‹ã‚’ç¢ºèªã—ã¦ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚');
      } finally {
        startBtn.disabled = false;
        startBtn.textContent = oldText;
      }
    });

    async function claimSeat(roomId, seat){
      const seatRef = doc(db, `rooms/${roomId}/seats/${seat}`);
      const displayName = (playerNameInput.value||'').trim();
      const color = playerColorInput.value || '#22aaff';
      try{
        const success = await runTransaction(db, async (tx) => {
          const snap = await tx.get(seatRef);
          if(!snap.exists()){
            tx.set(seatRef, { claimedByUid: CURRENT_UID, displayName, color, claimedAt: serverTimestamp(), heartbeatAt: serverTimestamp() });
            return true;
          }
          const data = snap.data();
          const stale = isSeatStale(data);
          if(!data.claimedByUid || stale || data.claimedByUid === CURRENT_UID){
            tx.set(seatRef, { claimedByUid: CURRENT_UID, displayName, color, claimedAt: serverTimestamp(), heartbeatAt: serverTimestamp() });
            return true;
          }
          return false;
        });
        return success;
      }catch(e){ console.error('claimSeat error', e); return false; }
    }

    async function onSnapshotOnce(ref){
      return await new Promise(resolve => {
        const unsub = onSnapshot(ref, snap => { unsub(); resolve(snap); });
      });
    }

    async function releaseSeat(roomId, seat){
      try{ await deleteDoc(doc(db, `rooms/${roomId}/seats/${seat}`)); }catch(e){ console.warn('releaseSeat error', e); }
    }

    let heartbeatTimer = null;
    let hostHeartbeatTimer = null;

    function startHostHeartbeat(roomId){
      stopHostHeartbeat();
      hostHeartbeatTimer = setInterval(async () => {
        try{
          await setDoc(doc(db, `rooms/${roomId}`), { hostHeartbeatAt: serverTimestamp() }, { merge: true });
        }catch(e){ console.warn('host HB failed', e); }
      }, 5000);
    }
    function stopHostHeartbeat(){ if(hostHeartbeatTimer){ clearInterval(hostHeartbeatTimer); hostHeartbeatTimer = null; } }

    function startHeartbeat(roomId, seat){
      stopHeartbeat();
      heartbeatTimer = setInterval(async () => {
        try{
          await setDoc(doc(db, `rooms/${roomId}/seats/${seat}`), { claimedByUid: CURRENT_UID, heartbeatAt: serverTimestamp() }, { merge: true });
        }catch(e){ console.warn('heartbeat failed', e); }
      }, 10000);
    }
    function stopHeartbeat(){ if(heartbeatTimer){ clearInterval(heartbeatTimer); heartbeatTimer = null; } }

    // ===== ã‚«ãƒ¼ãƒ‰åŒæœŸãƒ»UI =====
    const field = document.getElementById("field");
    const container = document.getElementById("container"); // â†è¿½åŠ 
    const previewImg = document.getElementById("preview-img");
    const previewInfo = document.getElementById("preview-info");
    const uploadArea = document.getElementById("upload-area");
    const fileInput = document.getElementById("file-input");
    const fieldSizeOptions = document.getElementById("field-size-options");
    


    // === è¿½åŠ : ã‚¨ãƒªã‚¢è‰²ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ï¼‰
    const DEFAULT_AREA_COLORS = {
      deck: '#ff9900',     // CSS: .deck-area{ background:#f90; }
      main: '#22dd88',     // CSS: .main-play-area{ background:#2d8; }
      hand: '#228be6'      // CSS: .hand-area{ background:#228be6; }
    };
    
    
    
    
    // ä¸¸å½¢ãƒ»åŠåˆ†ã‚µã‚¤ã‚ºã®ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼SVGã‚’å‹•çš„ã«ä½œã‚‹
function makeCounterIcon(label /* '+1' | '+10' | '-1' | '-10' */){
  // 60x80ï¼ˆã‚‚ã¨ã®åŠåˆ†ï¼‰ã€ç™½ä¸¸ã«é»’æ–‡å­—
  // æ–‡å­—ãŒ3æ¡ï¼ˆ+10, -10ï¼‰ã®æ™‚ã¯å°‘ã—å°ã•ã‚
  const fontSize = (label.length >= 3) ? 28 : 32;
  const svg =
    `<svg xmlns="http://www.w3.org/2000/svg" width="60" height="80" viewBox="0 0 60 80">
       <rect width="60" height="80" fill="black"/>
       <circle cx="30" cy="40" r="24" fill="white"/>
       <text x="30" y="46" font-size="${fontSize}" font-family="Arial, Helvetica, sans-serif"
             text-anchor="middle" fill="black">${label}</text>
     </svg>`;
  return 'data:image/svg+xml;utf8,' + encodeURIComponent(svg);
}

// å…±é€šï¼šä»»æ„ã®ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã‚’ç”Ÿæˆ
window.spawnCounter = async function(kind /* '+1' | '+10' | '-1' | '-10' */) {
  if (!CURRENT_ROOM || !CURRENT_PLAYER || !CURRENT_UID) {
    alert('ãƒ«ãƒ¼ãƒ ã«å‚åŠ ã—ã¦ã‹ã‚‰å®Ÿè¡Œã—ã¦ãã ã•ã„');
    return;
  }

  const icon = makeCounterIcon(kind);
  const { x, y } = randomPointInDeck(CURRENT_PLAYER);

  try {
    const ref = await addDoc(collection(db, `rooms/${CURRENT_ROOM}/cards`), {
      x, y,
      zIndex: getMaxZIndex() + 1,
      faceUp: true,
      imageUrl: icon,            // å°ã•ã‚SVGãƒ‡ãƒ¼ã‚¿URL
      ownerUid: CURRENT_UID,
      ownerSeat: CURRENT_PLAYER,
      rotation: 0,
      type: 'counter',
      counterKind: kind,         // '+1' | '+10' | '-1' | '-10'
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp()
    });
    markLocal(ref.id);

    // DOMå³æ™‚åæ˜ 
    let el = cardDomMap.get(ref.id);
    if (!el) {
      el = createCardDom(ref.id, icon, {
        x, y, zIndex: getMaxZIndex() + 1, faceUp: true,
        ownerUid: CURRENT_UID, ownerSeat: CURRENT_PLAYER,
        rotation: 0, type: 'counter', counterKind: kind
      });
      cardDomMap.set(ref.id, el);
      field.appendChild(el);
    }
    applyCardState(el, {
      x, y, zIndex: parseInt(el.style.zIndex) || (getMaxZIndex() + 1),
      faceUp: true,
      imageUrl: icon,
      ownerUid: CURRENT_UID, ownerSeat: CURRENT_PLAYER,
      rotation: 0, type: 'counter', counterKind: kind
    });
  } catch (e) {
    console.error(e);
    alert('ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã®é…ç½®ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚’ã”ç¢ºèªãã ã•ã„ã€‚');
  }
};
    
    
    
    
    // === è¿½åŠ : ãƒ«ãƒ¼ãƒ çµ‚äº†ãƒœã‚¿ãƒ³ã®åˆ¶å¾¡ ===
const endRoomBtn = document.getElementById('end-room-btn');

/** ãƒ›ã‚¹ãƒˆåº§å¸­ã®ãƒ›ã‚¹ãƒˆæœ¬äººã ã‘ã«ãƒœã‚¿ãƒ³ã‚’å‡ºã™ */
function updateEndRoomButtonVisibility(){
  const isHostUid = !!(CURRENT_ROOM_META?.hostUid && CURRENT_UID && CURRENT_ROOM_META.hostUid === CURRENT_UID);
  const isHostSeat = !!(CURRENT_ROOM_META?.hostSeat && CURRENT_PLAYER && CURRENT_ROOM_META.hostSeat === CURRENT_PLAYER);
  const show = !!(CURRENT_ROOM && isHostUid && isHostSeat);
  if (endRoomBtn) endRoomBtn.style.display = show ? 'block' : 'none';
}

/** ã‚¯ãƒªãƒƒã‚¯ã§ãƒ«ãƒ¼ãƒ çµ‚äº†ï¼ˆcards/seats å…¨å‰Šé™¤ + roomClosed: trueï¼‰ */
endRoomBtn?.addEventListener('click', async () => {
  if (!(CURRENT_ROOM && CURRENT_ROOM_META?.hostUid === CURRENT_UID && CURRENT_ROOM_META?.hostSeat === CURRENT_PLAYER)) {
    alert('ã“ã®æ“ä½œã¯ã€ãƒ›ã‚¹ãƒˆåº§å¸­ã«åº§ã£ãŸãƒ›ã‚¹ãƒˆã®ã¿å®Ÿè¡Œã§ãã¾ã™ã€‚');
    return;
  }
  if (!confirm('ãƒ«ãƒ¼ãƒ ã‚’çµ‚äº†ã—ã¾ã™ã€‚å…¨ã‚«ãƒ¼ãƒ‰ã¨åº§å¸­æƒ…å ±ãŒå‰Šé™¤ã•ã‚Œã€å…¨å“¡ãŒé€€å‡ºã—ã¾ã™ã€‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ')) return;

  endRoomBtn.disabled = true;
  try {
    await cleanupAndCloseRoom(CURRENT_ROOM); // æ—¢å­˜é–¢æ•°: cards/seatså…¨å‰Šé™¤ + roomClosed: true ã‚’ã‚»ãƒƒãƒˆ
    // è‡ªåˆ†ï¼ˆãƒ›ã‚¹ãƒˆï¼‰å´ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã¨ãƒ­ãƒ“ãƒ¼å¾©å¸°
    try { if (unsubscribeCards) { unsubscribeCards(); unsubscribeCards = null; } } catch(_) {}
    try { if (unsubscribeSeats) { unsubscribeSeats(); unsubscribeSeats = null; } } catch(_) {}
    try { if (unsubscribeRoomDoc) { unsubscribeRoomDoc(); unsubscribeRoomDoc = null; } } catch(_) {}
    try { stopHeartbeat(); } catch(_) {}
    try { stopHostHeartbeat(); } catch(_) {}
    try { stopHostWatch(); } catch(_) {}
    try { if (CURRENT_ROOM && CURRENT_PLAYER) releaseSeat(CURRENT_ROOM, CURRENT_PLAYER); } catch(_) {}

    CURRENT_ROOM = null;
    CURRENT_PLAYER = null;
    sessionIndicator.textContent = 'ROOM: - / PLAYER: -';
    lobby.style.display = 'flex';
    alert('ãƒ«ãƒ¼ãƒ ã‚’çµ‚äº†ã—ã¾ã—ãŸã€‚');

  } catch (e) {
    console.error(e);
    alert('ãƒ«ãƒ¼ãƒ ã®çµ‚äº†ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚’ã”ç¢ºèªã®ã†ãˆå†è©¦è¡Œã—ã¦ãã ã•ã„ã€‚');
  } finally {
    endRoomBtn.disabled = false;
    updateEndRoomButtonVisibility();
  }
});
    
    
    
    
    
    
    

    let zoom = 1, panOffsetX = 0, panOffsetY = 0, selectedCard = null;

    const cardDomMap = new Map();
    const localChangeMap = new Map();
    function markLocal(id){ localChangeMap.set(id, Date.now()); setTimeout(()=>localChangeMap.delete(id), 800); }
    function isLocalRecent(id){ const t = localChangeMap.get(id); return t && (Date.now() - t < 800); }

    // ãƒ•ãƒ«è§£åƒåº¦ã¯ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰è€…ã ã‘ãŒä¿æŒï¼ˆä»–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯ã‚µãƒ ãƒã®ã¿ï¼‰
    const fullImageStore = new Map(); // key: cardId, value: dataURL(full)

    let unsubscribeCards = null;
    let handlersBound = false;

    function startSession(roomId, playerId){
      CURRENT_ROOM = roomId; CURRENT_PLAYER = playerId;
      updateEndRoomButtonVisibility(); // è¿½åŠ 
      sessionIndicator.textContent = `ROOM: ${CURRENT_ROOM} / PLAYER: P${CURRENT_PLAYER}`;
      lobby.style.display = 'none';
      startHeartbeat(roomId, playerId);
      if (IS_ROOM_CREATOR) startHostHeartbeat(roomId);

      joinRoomInput.value = CURRENT_ROOM;
      loadSeatStatus();

      window.addEventListener('beforeunload', () => {
        stopHeartbeat();
        stopHostWatch();
        if (IS_ROOM_CREATOR && CURRENT_ROOM) {
          cleanupAndCloseRoom(CURRENT_ROOM).catch(console.warn);
          stopHostHeartbeat();
        }
        releaseSeat(roomId, playerId);
      });

      initializePlayField();
      subscribeCards();
      startHostWatch();
      renderAreaColors(); // è¿½åŠ : å…¥å®¤ç›´å¾Œã«ã‚¨ãƒªã‚¢è‰²åæ˜ 
      renderHPPanel(); // è¿½åŠ : å…¥å®¤ç›´å¾Œã«HPæç”»
    }

    function subscribeCards(){
      if(unsubscribeCards){ unsubscribeCards(); unsubscribeCards = null; }
      const qCards = collection(db, `rooms/${CURRENT_ROOM}/cards`);
      unsubscribeCards = onSnapshot(qCards, snap => {
        snap.docChanges().forEach(change => {
          const data = change.doc.data();
          const id = change.doc.id;
          if(change.type === 'removed'){
            const el = cardDomMap.get(id); if(el){ el.remove(); cardDomMap.delete(id); }
            return;
          }
          upsertCardFromRemote(id, data);
        });
      });
    }

    function upsertCardFromRemote(id, data){
      let el = cardDomMap.get(id) || document.querySelector(`[data-card-id="${id}"]`);
      const exists = !!el;
      if (!exists && !isLocalRecent(id)) {
        el = createCardDom(id, data.imageUrl, data); // imageUrl ã¯ã‚µãƒ ãƒ
        cardDomMap.set(id, el);
        field.appendChild(el);
      }
      if (el) applyCardState(el, data);
    }

    function createCardDom(cardId, imageSrc, state){
      const card = document.createElement("div");
      card.className = "card";
      if (state?.type === 'counter') card.classList.add('counter'); // â†è¿½åŠ 
      card.dataset.cardId = cardId;
      card.dataset.ownerUid = state?.ownerUid || '';
      card.dataset.ownerSeat = state?.ownerSeat ? String(state.ownerSeat) : '';
      card.setAttribute('data-owner', (card.dataset.ownerSeat && card.dataset.ownerSeat !== String(CURRENT_PLAYER)) ? 'other' : 'me');

      const img = document.createElement("img");
      img.src = imageSrc; // ã‚µãƒ ãƒï¼ˆå°ã•ã‚ï¼‰
      img.decoding = 'async';
      img.loading = 'lazy';
      card.appendChild(img);

      makeDraggable(card);

card.addEventListener("click", async e => {
  e.stopPropagation();

  // ã‚¯ãƒªãƒƒã‚¯ã§æœ€å‰é¢ã¸ï¼ˆã‚«ãƒ¼ãƒ‰/ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼å…±é€šï¼‰
  const newZ = getMaxZIndex() + 1;
  card.style.zIndex = newZ;
  try { await updateCard(cardId, { zIndex: newZ, updatedAt: serverTimestamp() }); } catch {}

  // é¸æŠè¡¨ç¤ºï¼ˆæ—¢å­˜ï¼‰
  if (selectedCard) selectedCard.classList.remove("selected");
  card.classList.add("selected");
  selectedCard = card;

  const full = fullImageStore.get(cardId); // ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰è€…ã®ã¿ä¿æŒï¼ˆã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã¯ç„¡ã„ã®ã§undefinedã§OKï¼‰
  const thumbEl = card.querySelector('img');

  if (thumbEl && thumbEl.style.display !== "none") {
    previewImg.src = full || thumbEl.src;
    previewImg.style.display = "block";
  } else {
    previewImg.src = "";
    previewImg.style.display = "none";
  }

  let ownerPlayerNum = "?";
  if (card.dataset.ownerSeat) ownerPlayerNum = `P${card.dataset.ownerSeat}`;
  previewInfo.textContent = `ã‚«ãƒ¼ãƒ‰ã®ã‚ªãƒ¼ãƒŠãƒ¼: ${ownerPlayerNum} / ã‚ãªãŸ: P${CURRENT_PLAYER || "?"}`;
});

      
      
// å³ã‚¯ãƒªãƒƒã‚¯ã§è¡¨è£ãƒˆã‚°ãƒ«ï¼ˆè‡ªåˆ†ã®ã‚«ãƒ¼ãƒ‰ã®ã¿ï¼ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã¯é™¤å¤–ï¼‰
card.addEventListener("contextmenu", async (e) => {
  e.preventDefault(); // OSã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒ¡ãƒ‹ãƒ¥ãƒ¼ã¯å‡ºã•ãªã„
  if (card.dataset.ownerSeat !== String(CURRENT_PLAYER)) return;
  if (card.classList.contains('counter')) return; // ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã¯è£è¿”ã•ãªã„ï¼ˆå¿…è¦ãªã‚‰å¤–ã—ã¦OKï¼‰

  const isFaceUp = card.dataset.faceUp === 'true';
  const nextFaceUp = !isFaceUp;

  // ãƒ­ãƒ¼ã‚«ãƒ«å³æ™‚åæ˜ 
  card.dataset.faceUp = nextFaceUp ? 'true' : 'false';
  const imgEl = card.querySelector('img');
  if (imgEl) {
    if (nextFaceUp) {
      imgEl.style.display = 'block';
      card.style.backgroundColor = '#fff';
      // é¸æŠä¸­ãªã‚‰ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚‚æ›´æ–°
      if (selectedCard === card) {
        const full = fullImageStore.get(cardId);
        previewImg.src = full || imgEl.src;
        previewImg.style.display = 'block';
      }
    } else {
      imgEl.style.display = 'none';
      card.style.backgroundColor = '#000';
      // é¸æŠä¸­ãªã‚‰ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’æ¶ˆã™
      if (selectedCard === card) {
        previewImg.src = '';
        previewImg.style.display = 'none';
      }
    }
  }

  // Firestoreã¸åæ˜ 
  await updateCard(cardId, { faceUp: nextFaceUp, updatedAt: serverTimestamp() });
});      
      
      
      
      
      
      
      // è¿½åŠ : ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã§å·¦ã¸90Â°å›è»¢ï¼ˆè‡ªåˆ†ã®ã‚«ãƒ¼ãƒ‰ã®ã¿ï¼‰
card.addEventListener("dblclick", async (e) => {
  e.stopPropagation();
  // è‡ªåˆ†ã®ã‚«ãƒ¼ãƒ‰ã ã‘æ“ä½œå¯
  if (card.dataset.ownerSeat !== String(CURRENT_PLAYER)) return;

  // ç¾åœ¨ã®è§’åº¦ï¼ˆstyle ã¾ãŸã¯ dataset / stateï¼‰ã‚’èª­ã¿å‡ºã—
  const currentStyle = card.style.transform || '';
  const match = currentStyle.match(/rotate\((-?\d+(?:\.\d+)?)deg\)/);
  const current = match ? parseFloat(match[1]) : (typeof state?.rotation === 'number' ? state.rotation : 0);

  // å·¦ã«90Â°ï¼ˆ= -90ï¼‰å›è»¢ â†’ 0..359 ã®ç¯„å›²ã«æ­£è¦åŒ–
  const next = ((current + 270) % 360 + 360) % 360;

  // ãƒ­ãƒ¼ã‚«ãƒ«å³æ™‚åæ˜ 
  card.style.transform = `rotate(${next}deg)`;

  // Firestore ã¸ä¿å­˜ï¼ˆåŒæœŸï¼‰
  await updateCard(cardId, { rotation: next, updatedAt: serverTimestamp() });
});
      
      
      
      return card;
    }

    function applyCardState(card, data){
      card.dataset.ownerUid = data.ownerUid || '';
      card.dataset.ownerSeat = (data.ownerSeat!=null) ? String(data.ownerSeat) : '';
      card.setAttribute('data-owner', (card.dataset.ownerSeat && card.dataset.ownerSeat !== String(CURRENT_PLAYER)) ? 'other' : 'me');

      card.style.left = `${data.x||0}px`;
      card.style.top  = `${data.y||0}px`;
      card.style.zIndex = data.zIndex || 1;
      
      // è¿½åŠ : å›è»¢ï¼ˆ0/90/180/270ãªã©ï¼‰ã‚’åæ˜ 
      const rot = (typeof data.rotation === 'number') ? data.rotation : 0;
      card.style.transform = `rotate(${rot}deg)`;
      
      
      card.dataset.faceUp = data.faceUp ? 'true' : 'false';
      const img = card.querySelector('img');
      if(img){
        if(data.faceUp){ img.style.display = 'block'; card.style.backgroundColor = '#fff'; }
        else { img.style.display = 'none'; card.style.backgroundColor = '#000'; }
        if(data.imageUrl && img.src !== data.imageUrl){ img.src = data.imageUrl; }
      }

      try {
        const viewerSeat = CURRENT_PLAYER;
        const x = parseFloat(card.style.left) || 0;
        const y = parseFloat(card.style.top)  || 0;
        let insideSeat = null;
        for (const s of [1,2,3,4]) {
          const hb = getHandBoundsForSeat(s);
          if (hb && isCenterInsideRect(x, y, hb)) { insideSeat = s; break; }
        }
        if (insideSeat && String(viewerSeat) !== String(insideSeat)) {
          const img = card.querySelector('img');
          if (img) { img.style.display = 'none'; card.style.backgroundColor = '#000'; }
        }
      } catch(_) {}
    }

    async function cleanupAndCloseRoom(roomId){
      // cardså‰Šé™¤
      const cardsCol = collection(db, `rooms/${roomId}/cards`);
      const cardsSnap = await getDocs(cardsCol);
      let batch = writeBatch(db);
      let count = 0;
      for (const docSnap of cardsSnap.docs) {
        batch.delete(doc(db, `rooms/${roomId}/cards/${docSnap.id}`));
        if (++count >= 450) { await batch.commit(); batch = writeBatch(db); count = 0; }
      }
      if (count > 0) await batch.commit();

      // seatså‰Šé™¤
      const seatsCol = collection(db, `rooms/${roomId}/seats`);
      const seatsSnap = await getDocs(seatsCol);
      batch = writeBatch(db); count = 0;
      for (const docSnap of seatsSnap.docs) {
        batch.delete(doc(db, `rooms/${roomId}/seats/${docSnap.id}`));
        if (++count >= 450) { await batch.commit(); batch = writeBatch(db); count = 0; }
      }
      if (count > 0) await batch.commit();

      await setDoc(doc(db, `rooms/${roomId}`), { roomClosed: true, updatedAt: serverTimestamp() }, { merge: true });
    }

    async function updateCard(cardId, patch){
      if(!CURRENT_ROOM) return;
      const ref = doc(db, `rooms/${CURRENT_ROOM}/cards/${cardId}`);
      markLocal(cardId);
      try { await updateDoc(ref, patch); } catch(e){ console.error('updateCard', e); }
    }

    // ========= ç”»åƒæŠ•å…¥ï¼šä¸¦åˆ—åˆ¶é™ + ã‚µãƒ ãƒç”Ÿæˆï¼ˆè»½é‡åŒ–ï¼‰ =========
    const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));
    const nextFrame = ()=>new Promise(r=>requestAnimationFrame(()=>r()));

    // ã‚µãƒ ãƒã®æœ€å¤§ã‚µã‚¤ã‚ºï¼ˆã‚«ãƒ¼ãƒ‰è¡¨ç¤ºã‚ˆã‚Šå°‘ã—å¤§ãã‚ã«ã—ã¦è¦‹æ „ãˆç¢ºä¿ï¼‰
    const THUMB_MAX_W = 240; // px
    const THUMB_MAX_H = 320; // px
    const PARALLEL = Math.max(2, Math.min(8, Math.floor((navigator.hardwareConcurrency||8)/2))); // ç«¯æœ«ã«å¿œã˜ã¦
    const BATCH_INSERT = 12;

    const fileQueue = [];
    let processing = false;

    function bindUploadHandlers(){
      uploadArea.addEventListener("click", () => fileInput.click());
      uploadArea.addEventListener("dragover", e => { e.preventDefault(); uploadArea.style.backgroundColor = "#eef"; });
      uploadArea.addEventListener("dragleave", () => { uploadArea.style.backgroundColor = "#fff"; });
      uploadArea.addEventListener("drop", e => { e.preventDefault(); uploadArea.style.backgroundColor = "#fff"; handleFiles(e.dataTransfer.files); });
      fileInput.addEventListener("change", e => handleFiles(e.target.files));
    }

    function handleFiles(files){
      const imgs = [...files].filter(f=>f.type.startsWith('image/'));
      for (const f of imgs) fileQueue.push(f);
      if (!processing) processQueue();
    }

    // ç”»åƒâ†’ã‚µãƒ ãƒï¼†ãƒ•ãƒ«ï¼ˆdataURLï¼‰
    async function fileToThumbAndFull(file){
      const bmp = await createImageBitmap(file); // é«˜é€Ÿãƒ‡ã‚³ãƒ¼ãƒ‰
      const sw = bmp.width, sh = bmp.height;
      const scale = Math.min(THUMB_MAX_W / sw, THUMB_MAX_H / sh, 1);
      const tw = Math.max(1, Math.round(sw * scale));
      const th = Math.max(1, Math.round(sh * scale));

      const canvas = document.createElement('canvas');
      canvas.width = tw; canvas.height = th;
      const ctx = canvas.getContext('2d', {alpha: false});
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'low';
      ctx.drawImage(bmp, 0, 0, tw, th);
      const thumbDataUrl = canvas.toDataURL('image/jpeg', 0.7); // è»½é‡

      // ãƒ•ãƒ«ã¯ãã®ã¾ã¾ï¼ˆã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰è€…ã®ã¿ä¿æŒï¼‰
      const fullDataUrl = await blobToDataURL(file);

      try { bmp.close?.(); } catch(_){}
      return { thumbDataUrl, fullDataUrl };
    }

    function blobToDataURL(blob){
      return new Promise((res, rej)=>{
        const fr = new FileReader();
        fr.onerror = rej;
        fr.onload = ()=>res(fr.result);
        fr.readAsDataURL(blob);
      });
    }

    async function processQueue(){
      processing = true;
      try{
        while (fileQueue.length){
          const chunk = fileQueue.splice(0, BATCH_INSERT);
          const groups = [];
          for (let i=0; i<chunk.length; i+=PARALLEL) groups.push(chunk.slice(i,i+PARALLEL));

          const frag = document.createDocumentFragment();

          for (const group of groups){
            const results = await Promise.all(group.map(async (file)=>{
              const {thumbDataUrl, fullDataUrl} = await fileToThumbAndFull(file);
              if (!CURRENT_ROOM || !CURRENT_PLAYER || !CURRENT_UID) return null;

              const {x,y} = randomPointInDeck(CURRENT_PLAYER);
              // Firestoreã«ã¯ã‚µãƒ ãƒã ã‘ä¿å­˜ï¼ˆãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯è»½é‡åŒ–ï¼‰
              const ref = await addDoc(collection(db, `rooms/${CURRENT_ROOM}/cards`), {
                x, y, zIndex: 1,
                faceUp: true,
                imageUrl: thumbDataUrl,
                ownerUid: CURRENT_UID,
                ownerSeat: CURRENT_PLAYER,
                rotation: 0,
                createdAt: serverTimestamp(),
                updatedAt: serverTimestamp()
              });
              markLocal(ref.id);

              // è‡ªåˆ†ã ã‘ãƒ•ãƒ«ã‚’ä¿æŒï¼ˆãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”¨ï¼‰
              fullImageStore.set(ref.id, fullDataUrl);

              // DOMã‚’å³æ™‚åæ˜ ï¼ˆã‚¹ãƒŠãƒƒãƒ—å¾…ã¡ã—ãªã„ï¼‰
              let el = cardDomMap.get(ref.id);
              if(!el){
                el = createCardDom(ref.id, thumbDataUrl, {
                  x, y, zIndex: 1, faceUp: true,
                  ownerUid: CURRENT_UID, ownerSeat: CURRENT_PLAYER
                });
                
                cardDomMap.set(ref.id, el);
                applyCardState(el, {
                  x, y, zIndex: 1, faceUp: true,
                  imageUrl: thumbDataUrl, ownerUid: CURRENT_UID, ownerSeat: CURRENT_PLAYER,
                  rotation: 0
                });
                
                frag.appendChild(el);
              }
              return true;
            }));

            // ãƒ¡ã‚¤ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ã«ä¸€æ¯
            await nextFrame();
          }

          if (frag.childNodes.length) field.appendChild(frag);
          await nextFrame();
        }
      } finally {
        processing = false;
      }
    }
    
    
    
    
    
    
    
    
    
    
    // ========= æ—¢å­˜ã®å˜ç™ºã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰APIã¯ã‚µãƒ ãƒæ–¹å¼ã¸ï¼ˆä»–å‡¦ç†ã‹ã‚‰å‘¼ã¶å ´åˆï¼‰ =========
    async function createCardRemote({ imageUrl }){
      // äº’æ›ï¼šæ¸¡ã•ã‚ŒãŸimageUrlï¼ˆãƒ•ãƒ«ï¼‰ã‹ã‚‰ã‚µãƒ ãƒç”Ÿæˆã—ã¦ä¿å­˜
      if(!CURRENT_ROOM) return;
      const fullBlob = await (await fetch(imageUrl)).blob();
      const {thumbDataUrl, fullDataUrl} = await fileToThumbAndFull(fullBlob);
      const { x: baseX, y: baseY } = randomPointInDeck(CURRENT_PLAYER);
      try{
        const ref = await addDoc(collection(db, `rooms/${CURRENT_ROOM}/cards`), {
          x: baseX, y: baseY, zIndex: 1, faceUp: true,
          imageUrl: thumbDataUrl,
          ownerUid: CURRENT_UID, ownerSeat: CURRENT_PLAYER,
          rotation: 0,
          createdAt: serverTimestamp(), updatedAt: serverTimestamp()
        });
        markLocal(ref.id);
        fullImageStore.set(ref.id, fullDataUrl);
        let el = cardDomMap.get(ref.id) || document.querySelector(`[data-card-id="${ref.id}"]`);
        if(!el){
          el = createCardDom(ref.id, thumbDataUrl, {
            x: baseX, y: baseY, zIndex: 1, faceUp: true,
            ownerUid: CURRENT_UID, ownerSeat: CURRENT_PLAYER
          });
          cardDomMap.set(ref.id, el);
          field.appendChild(el);
        }
        
        applyCardState(el, {
          x: baseX, y: baseY, zIndex: 1, faceUp: true,
          imageUrl: thumbDataUrl, ownerUid: CURRENT_UID, ownerSeat: CURRENT_PLAYER,
          rotation: 0
        });
        
      }catch(e){ console.error('createCardRemote', e); }
    }

    // ========= æ—¢å­˜ã®UIæ“ä½œ =========
 function makeDraggable(card){
   const DRAG_THRESHOLD = 5; // pxï¼šã“ã‚Œæœªæº€ã®ç§»å‹•ã¯ãƒ‰ãƒ©ãƒƒã‚°ã«ã—ãªã„
   let isDragging = false;
   let startClientX = 0, startClientY = 0;
   let grabOffsetX = 0, grabOffsetY = 0;

   card.addEventListener("mousedown", (e) => {
     if (e.button !== 0) return;
     if (card.dataset.ownerSeat !== String(CURRENT_PLAYER)) return;
     // ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ï¼ˆ2å›ç›®ã® mousedownï¼‰ã¯ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹ã‚’ç„¡è¦–
     if (e.detail > 1) return;

     const rect = field.getBoundingClientRect();
     const mouseX = (e.clientX - rect.left - panOffsetX) / zoom;
     const mouseY = (e.clientY - rect.top - panOffsetY) / zoom;

     startClientX = e.clientX;
     startClientY = e.clientY;
     grabOffsetX = mouseX - (parseFloat(card.style.left || '0') || 0);
     grabOffsetY = mouseY - (parseFloat(card.style.top  || '0') || 0);

     const onMove = (e2) => {
       const dx = e2.clientX - startClientX;
       const dy = e2.clientY - startClientY;
       // é–¾å€¤ã‚’è¶…ãˆãŸã‚‰åˆã‚ã¦ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹
       if (!isDragging) {
         if (Math.hypot(dx, dy) < DRAG_THRESHOLD) return;
         isDragging = true;
         card.style.cursor = "grabbing";
         card.style.zIndex = getMaxZIndex() + 1;
       }
       const x = (e2.clientX - rect.left - panOffsetX) / zoom;
       const y = (e2.clientY - rect.top  - panOffsetY) / zoom;
       card.style.left = `${x - grabOffsetX}px`;
       card.style.top  = `${y - grabOffsetY}px`;
     };

     const onUp = async () => {
       document.removeEventListener("mousemove", onMove);
       document.removeEventListener("mouseup", onUp);
       card.style.cursor = "grab";
       // ãƒ‰ãƒ©ãƒƒã‚°ã¨ã—ã¦æˆç«‹ã—ã¦ã„ãªã‘ã‚Œã°ã€ä½ç½®æ›´æ–°ã—ãªã„ï¼ˆã‚¯ãƒªãƒƒã‚¯/ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯å„ªå…ˆï¼‰
       if (!isDragging) return;
       isDragging = false;
       const id = card.dataset.cardId;
       const x = parseFloat(card.style.left) || 0;
       const y = parseFloat(card.style.top)  || 0;
       const zIndex = parseInt(card.style.zIndex) || 1;
       await updateCard(id, { x, y, zIndex, updatedAt: serverTimestamp() });
     };

     document.addEventListener("mousemove", onMove);
     document.addEventListener("mouseup", onUp);
   });
 }
 
    function getMaxZIndex(){ let max=0; document.querySelectorAll(".card").forEach(c=>{ const z=parseInt(c.style.zIndex)||0; if(z>max) max=z; }); return max; }

    window.faceDownAll = async function(){
      for(const [id, el] of cardDomMap){
        if (el.dataset.ownerSeat !== String(CURRENT_PLAYER)) continue;
        await updateCard(id, { faceUp: false, updatedAt: serverTimestamp() });
      }
      previewImg.src = ""; previewImg.style.display = "none";
    }
    
    window.faceUpAll = async function(){
      for(const [id, el] of cardDomMap){
        if (el.dataset.ownerSeat !== String(CURRENT_PLAYER)) continue;
        await updateCard(id, { faceUp: true, updatedAt: serverTimestamp() });
      }
    }
    
    
    // è¿½åŠ : è‡ªåˆ†ã®ã‚«ãƒ¼ãƒ‰ã®å›è»¢ã‚’ã™ã¹ã¦ 0 åº¦ã«ãƒªã‚»ãƒƒãƒˆ
window.resetMyCardRotation = async function () {
  if (!CURRENT_ROOM || !CURRENT_UID) {
    alert('ãƒ«ãƒ¼ãƒ ã«å‚åŠ ã—ã¦ã‹ã‚‰å®Ÿè¡Œã—ã¦ãã ã•ã„');
    return;
  }

  // ãƒ­ãƒ¼ã‚«ãƒ«è¡¨ç¤ºã‚’å³æ™‚åæ˜ ã—ã¤ã¤ã€Firestore ã‚‚æ›´æ–°
  const tasks = [];
  for (const [id, el] of cardDomMap) {
    if (el.dataset.ownerSeat !== String(CURRENT_PLAYER)) continue; // è‡ªåˆ†ã®ã‚«ãƒ¼ãƒ‰ã®ã¿
    el.style.transform = 'rotate(0deg)';                           // å³æ™‚åæ˜ 
    tasks.push(updateCard(id, { rotation: 0, updatedAt: serverTimestamp() }));
  }

  try {
    await Promise.all(tasks);
  } catch (e) {
    console.error(e);
    alert('ãƒªã‚»ãƒƒãƒˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯çŠ¶æ³ã‚’ç¢ºèªã—ã¦å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚');
  }
};
    

    window.deleteMyCards = async function(){
      if (!CURRENT_ROOM || !CURRENT_UID) { alert('ãƒ«ãƒ¼ãƒ ã«å‚åŠ ã—ã¦ã‹ã‚‰å®Ÿè¡Œã—ã¦ãã ã•ã„'); return; }
      if (!confirm('æœ¬å½“ã«è‡ªåˆ†ã®å…¨ã‚«ãƒ¼ãƒ‰ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿã“ã®æ“ä½œã¯å–ã‚Šæ¶ˆã›ã¾ã›ã‚“ã€‚')) return;
      try {
        const cardsCol = collection(db, `rooms/${CURRENT_ROOM}/cards`);
        const q = query(cardsCol, where('ownerUid', '==', CURRENT_UID));
        const snap = await getDocs(q);
        if (snap.empty) { alert('å‰Šé™¤å¯¾è±¡ã®ã‚«ãƒ¼ãƒ‰ã¯ã‚ã‚Šã¾ã›ã‚“'); return; }
        let batch = writeBatch(db);
        let count = 0;
        const removedIds = [];
        for (const docSnap of snap.docs) {
          batch.delete(doc(db, `rooms/${CURRENT_ROOM}/cards/${docSnap.id}`));
          removedIds.push(docSnap.id);
          if (++count >= 450) { await batch.commit(); batch = writeBatch(db); count = 0; }
        }
        if (count > 0) await batch.commit();
        removedIds.forEach(id => {
          const el = cardDomMap.get(id);
          if (el) { el.remove(); cardDomMap.delete(id); }
          fullImageStore.delete(id);
        });
        if (previewImg) { previewImg.src = ''; previewImg.style.display = 'none'; }
        alert(`å‰Šé™¤ã—ã¾ã—ãŸï¼ˆ${removedIds.length}æšï¼‰`);
      } catch (e) {
        console.error(e);
        alert('å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯çŠ¶æ³ã‚’ç¢ºèªã—ã¦å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚');
      }
    };
    
    
    
    // ===== å…¨ã‚«ãƒ¼ãƒ‰ä¸€è¦§ï¼ˆè‡ªåˆ†ï¼‰ =====
const cardListModal = document.getElementById('card-list-modal');
const cardListGrid  = document.getElementById('card-list-grid');
const cardListClose = document.getElementById('card-list-close');

window.openMyCardsDialog = function(){
  if (!CURRENT_ROOM || !CURRENT_PLAYER) { alert('ãƒ«ãƒ¼ãƒ ã«å‚åŠ ã—ã¦ã‹ã‚‰å®Ÿè¡Œã—ã¦ãã ã•ã„'); return; }

  // ã‚°ãƒªãƒƒãƒ‰åˆæœŸåŒ–
  cardListGrid.innerHTML = '';

  // è‡ªåˆ†ã®ã‚«ãƒ¼ãƒ‰ã ã‘é›†ã‚ã‚‹ï¼ˆã‚µãƒ ãƒã¯ full ãŒã‚ã‚Œã°ãã‚Œã€ãªã‘ã‚Œã° img.srcï¼‰
  const mine = [];
  for (const [id, el] of cardDomMap) {
    if (el.dataset.ownerSeat === String(CURRENT_PLAYER)) {
      const imgEl = el.querySelector('img');
      const src = fullImageStore.get(id) || (imgEl ? imgEl.src : '');
      mine.push({ id, src });
    }
  }

  if (mine.length === 0) {
    const empty = document.createElement('div');
    empty.textContent = 'ã¾ã è‡ªåˆ†ã®ã‚«ãƒ¼ãƒ‰ãŒã‚ã‚Šã¾ã›ã‚“ã€‚';
    empty.style.cssText = 'color:#666;font-size:14px;text-align:center;padding:24px 12px;';
    cardListGrid.appendChild(empty);
  } else {
    mine.forEach(({id, src}) => {
      const item = document.createElement('div');
      item.style.cssText = 'border:1px solid #ddd;border-radius:10px;padding:6px;cursor:pointer;display:flex;align-items:center;justify-content:center;background:#fafafa;';
      item.title = id;
      const img = document.createElement('img');
      img.src = src;
      img.alt = 'ã‚«ãƒ¼ãƒ‰';
      img.style.cssText = 'width:100%;height:auto;object-fit:contain;border-radius:6px;';
      item.appendChild(img);

      item.addEventListener('mouseenter', () => { item.style.outline = '3px solid #66aaff'; });
      item.addEventListener('mouseleave', () => { item.style.outline = 'none'; });

      item.addEventListener('click', async () => {
        await focusCardById(id); // æœ€å‰é¢ï¼†é¸æŠï¼ˆè¡¨è£ã¯å¤‰ãˆãªã„ï¼‰
        closeMyCardsDialog();
      });

      cardListGrid.appendChild(item);
    });
  }

  // è¡¨ç¤º
  cardListModal.style.display = 'flex';
};

function closeMyCardsDialog(){
  cardListModal.style.display = 'none';
}

cardListClose?.addEventListener('click', closeMyCardsDialog);
cardListModal?.addEventListener('click', (e) => {
  if (e.target === cardListModal) closeMyCardsDialog(); // ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹
});

/** æŒ‡å®šIDã®ã‚«ãƒ¼ãƒ‰ã‚’æœ€å‰é¢ã«ã—ã¦é¸æŠçŠ¶æ…‹ã«ã™ã‚‹ï¼ˆè¡¨è£ã¯ä¿æŒï¼‰ */
async function focusCardById(cardId){
  const el = cardDomMap.get(cardId) || document.querySelector(`[data-card-id="${cardId}"]`);
  if (!el) return;

  // zIndex ã‚’æœ€å‰é¢ï¼ˆFirestoreã«ã‚‚åæ˜ ï¼‰
  const newZ = getMaxZIndex() + 1;
  el.style.zIndex = newZ;
  try { await updateCard(cardId, { zIndex: newZ, updatedAt: serverTimestamp() }); } catch {}

  // é¸æŠçŠ¶æ…‹ã«ï¼ˆæ—¢å­˜ã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼å‹•ä½œã‚‚è¸è¥²ï¼‰
  if (selectedCard) selectedCard.classList.remove('selected');
  el.classList.add('selected');
  selectedCard = el;

  const full = fullImageStore.get(cardId);
  const thumbEl = el.querySelector('img');
  if (thumbEl && thumbEl.style.display !== 'none') {
    previewImg.src = full || thumbEl.src;
    previewImg.style.display = 'block';
  } else {
    previewImg.src = '';
    previewImg.style.display = 'none';
  }

  let ownerPlayerNum = el.dataset.ownerSeat ? `P${el.dataset.ownerSeat}` : '?';
  previewInfo.textContent = `ã‚«ãƒ¼ãƒ‰ã®ã‚ªãƒ¼ãƒŠãƒ¼: ${ownerPlayerNum} / ã‚ãªãŸ: P${CURRENT_PLAYER || "?"}`;
}
    
    
    
    
    
    
    window.toggleFieldSizeOptions = function(){ fieldSizeOptions.style.display = fieldSizeOptions.style.display==="none"?"block":"none"; }
    window.setFieldSize = function(size){ const sizes={ small:[3000,1500], medium:[5000,2500], large:[10000,5000] }; const [w,h]=sizes[size]||sizes.small; field.style.width=`${w}px`; field.style.height=`${h}px`; field.style.transform=`translate(${panOffsetX}px, ${panOffsetY}px) scale(${zoom})`; }
    window.alignDecks = function(){ /* è¡¨ç¤ºã®ã¿ */ }
    window.shuffleDecks = async function(){
      if(!CURRENT_ROOM || !CURRENT_PLAYER) return;
      const srcBounds = getDeckBoundsForSeat(CURRENT_PLAYER);
      if(!srcBounds){ alert('ã‚ãªãŸã®ãƒ‡ãƒƒã‚­ã‚¨ãƒªã‚¢ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“'); return; }
      const targets = getCardsInsideRect(srcBounds);
      if(targets.length === 0) return;
      shuffleArray(targets);
      const dstBounds = getDeckBoundsForSeat(CURRENT_PLAYER);
      if(!dstBounds){ alert('ã‚ãªãŸã®ãƒ‡ãƒƒã‚­ã‚¨ãƒªã‚¢ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“'); return; }
      const centerX = Math.round(dstBounds.minX + (dstBounds.width  - CARD_W)/2);
      const centerY = Math.round(dstBounds.minY + (dstBounds.height - CARD_H)/2);
      const baseZ = getMaxZIndex() + 1;
      let z = baseZ;
      for(const { id, el } of targets){
        el.style.left = `${centerX}px`;
        el.style.top  = `${centerY}px`;
        el.style.zIndex = z++;
        await updateCard(id, { x: centerX, y: centerY, zIndex: parseInt(el.style.zIndex) || z, updatedAt: serverTimestamp() });
      }
    };

function bindPanZoomHandlers(){
  // ã‚ºãƒ¼ãƒ ï¼ˆãã®ã¾ã¾ï¼‰
  field.addEventListener("wheel", e => {
    if(e.ctrlKey) return;
    e.preventDefault();
    const rect = field.getBoundingClientRect();
    const cx = e.clientX - rect.left;
    const cy = e.clientY - rect.top;
    const scale = 0.1;
    const old = zoom;
    zoom += e.deltaY < 0 ? scale : -scale;
    zoom = Math.max(0.3, Math.min(zoom, 3));
    const sx = (cx - panOffsetX) / old;
    const sy = (cy - panOffsetY) / old;
    panOffsetX = cx - sx * zoom;
    panOffsetY = cy - sy * zoom;
    field.style.transform = `translate(${panOffsetX}px, ${panOffsetY}px) scale(${zoom})`;
  }, { passive:false });

  // ãƒ‘ãƒ³ï¼šcontainerã§æ‹¾ã†ï¼ˆã‚«ãƒ¼ãƒ‰ãƒ»ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ç„¡è¦–ï¼ã—ãã„å€¤ã‚ã‚Šï¼‰
  container.addEventListener("mousedown", e => {
    if (e.button !== 0) return;              // å·¦ã‚¯ãƒªãƒƒã‚¯ã®ã¿
    if (e.detail > 1) return;                // ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯æ™‚ã¯é–‹å§‹ã—ãªã„
    if (e.target.closest(".card")) return;   // ã‚«ãƒ¼ãƒ‰ä¸Šã¯ãƒ‘ãƒ³ã—ãªã„

    const TH = 5; // px
    let panning = false;
    let sx = e.clientX, sy = e.clientY;

    // ç”»é¢å¤–ã¾ã§ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ã‚‚åˆ‡ã‚Œãªã„ã‚ˆã†ã«documentã§è¿½å¾“
    document.body.style.userSelect = 'none';
    container.style.cursor = 'grabbing';

    const onMove = e2 => {
      const dx = e2.clientX - sx;
      const dy = e2.clientY - sy;
      if (!panning) {
        if (Math.hypot(dx, dy) < TH) return; // ã—ãã„å€¤æœªæº€ã¯ç„¡è¦–ï¼ˆã‚¯ãƒªãƒƒã‚¯åˆ¤å®šã¨å…±å­˜ï¼‰
        panning = true;
      }
      panOffsetX += dx;
      panOffsetY += dy;
      sx = e2.clientX; sy = e2.clientY;
      field.style.transform = `translate(${panOffsetX}px, ${panOffsetY}px) scale(${zoom})`;
    };

    const cleanup = () => {
      document.removeEventListener("mousemove", onMove);
      document.removeEventListener("mouseup", cleanup);
      document.body.style.userSelect = '';
      container.style.cursor = '';
    };

    document.addEventListener("mousemove", onMove);
    document.addEventListener("mouseup", cleanup);
  });

  // ç©ºã‚¯ãƒªãƒƒã‚¯ã§é¸æŠè§£é™¤ï¼ˆå¾“æ¥ã©ãŠã‚Šï¼‰
  field.addEventListener("click", () => {
    if (selectedCard) {
      selectedCard.classList.remove("selected");
      selectedCard = null;
      previewImg.src = "";
      previewImg.style.display = "none";
    }
  });
}
    
    
    /* ï¼ˆä»»æ„ï¼‰åˆå›åº§å¸­ä½œæˆæ™‚ã« hp:0 ã‚’å…¥ã‚Œã¦ãŠããŸã„å ´åˆã¯ claimSeat å†… tx.set ã« hp ã‚’ä»˜ä¸
       æ—¢ã«å­˜åœ¨ã—ã¦ hp ãŒæ•°å­—ãªã‚‰ç¶­æŒã€ç„¡ã‘ã‚Œã° 0 ã‚’è¨­å®š:
       tx.set(seatRef, {
         claimedByUid: CURRENT_UID, displayName, color,
         claimedAt: serverTimestamp(), heartbeatAt: serverTimestamp(),
         hp: (snap.exists() && typeof snap.data()?.hp === 'number') ? snap.data().hp : 0
       });
    */
    
    
    function initializePlayField(){
      setFieldSize('small');
      if (!handlersBound) {
        bindUploadHandlers();
        bindPanZoomHandlers();
        bindAreaColorHandlers(); // è¿½åŠ : ã‚¨ãƒªã‚¢è‰²ã®ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ç·¨é›†
        handlersBound = true;
      }
    }
  </script>
</body>
</html>
